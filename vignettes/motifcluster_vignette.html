<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>\tableofcontents
\pagebreak</p>

<h1>Introduction</h1>

<p>This vignette demonstrates how to use the R package <code>motifcluster</code>.
These methods are detailed in the paper
<em>Motif-Based Spectral Clustering of Weighted Directed Networks</em>,
which is available at <a href="arxivpaper"><code>arXiv:2004.01293</code></a> [@UnderwoodElliottCucuringu_2020_Motifs].
The functionality of the <code>motifcluster</code> package falls into a few main categories:</p>

<ul>
<li>Building motif adjacency matrices</li>
<li>Sampling random weighted directed networks</li>
<li>Spectral embedding with motif adjacency matrices</li>
<li>Motif-based spectral clustering</li>
</ul>

<p>This vignette comprehensibly demonstrates all of these functionalities,
showcasing the full capability of the <code>motifcluster</code> package.
We first load some helpful packages for this tutorial:</p>

<pre><code class="r">library(devtools)
library(mclust)
</code></pre>

<p>The <code>motifcluster</code> package can be installed from GitHub with:</p>

<pre><code class="r">install_github(&quot;wgunderwood/motifcluster/R&quot;)
</code></pre>

<p>The package can then be loaded from within R with:</p>

<pre><code class="r">library(motifcluster)
</code></pre>

<h1>Building motif adjacency matrices</h1>

<p>The main novelty in the <code>motifcluster</code> package is its ability to
build a wide variety of motif adjacency matrices (MAMs), and to do so quickly.
There are several options to consider when building an MAM,
which are covered in this section.</p>

<h2>An example network</h2>

<p>In order to demonstrate the construction of MAMs,
we first need a small weighted directed network
\(\mathcal{G}_1\) to use as an example.
Note that throughout this package we represent networks by their
weighted directed adjacency matrices (possibly in sparse form).
This means that for use alongside R packages such as <code>igraph</code>,
one must manually convert between adjacency matrices and
<code>igraph</code> objects.</p>

<pre><code class="r">G1 &lt;- matrix(c(
  0, 2, 0, 0,
  0, 0, 2, 3,
  0, 4, 0, 0,
  4, 0, 5, 0
), byrow = TRUE, nrow = 4)
</code></pre>

<h2>Basic motif adjacency matrix construction</h2>

<p>The <code>build_motif_adjacency_matrix</code> function is the main workhorse
for building MAMs with <code>motifcluster</code>.
Let&#39;s use it to build an MAM for the network \(\mathcal{G}_1\).
First we must choose a motif to look for.
A full list can be obtained with:</p>

<pre><code class="r">get_motif_names()
#&gt;   [1] &quot;Ms&quot;    &quot;Md&quot;    &quot;M1&quot;    &quot;M2&quot;    &quot;M3&quot;    &quot;M4&quot;    &quot;M5&quot;    &quot;M6&quot;    &quot;M7&quot;   
#&gt;  [10] &quot;M8&quot;    &quot;M9&quot;    &quot;M10&quot;   &quot;M11&quot;   &quot;M12&quot;   &quot;M13&quot;   &quot;Mcoll&quot; &quot;Mexpa&quot;
</code></pre>

<p>Let&#39;s use the 3-cycle motif \(\mathcal{M}_1\).</p>

<pre><code class="r">build_motif_adjacency_matrix(G1, motif_name = &quot;M1&quot;)
#&gt;  4 x 4 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;              
#&gt;  [1,] . 1 . 1
#&gt;  [2,] 1 . . 1
#&gt;  [3,] . . . .
#&gt;  [4,] 1 1 . .
</code></pre>

<p>Note that all the entries are zero except for entries
\((1,2)\),
\((1,4)\),
\((2,1)\),
\((2,4)\),
\((4,1)\),
and
\((4,2)\).
This is because vertices 1, 2 and 4 form an exact copy of
the motif \(\mathcal{M}_1\) in the network \(\mathcal{G}_1\),
and the  $(i,j)$th MAM entry simply counts the number of instances
containing both vertices \(i\) and \(j\).</p>

<h2>Functional and structural motif adjacency matrices</h2>

<p>Looking at our example network \(\mathcal{G}_1\) again,
you might notice that there is seemingly another instance
of the motif \(\mathcal{M}_1\)
in our network \(\mathcal{G}_1\),
on the vertices 2, 3 and 4,
albeit with an &ldquo;extra&rdquo; edge from 2 to 3.
The reason for this is that we instructed
<code>build_motif_adjacency_matrix</code>
to look for <em>structural</em> motif instances (this is the default).
Structural instances require an exact match, with no extra edges.
If we want to also include instances which may have extra edges present,
we must instead use functional motif instances:</p>

<pre><code class="r">build_motif_adjacency_matrix(G1, motif_name = &quot;M1&quot;, motif_type = &quot;func&quot;)
#&gt;  4 x 4 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;              
#&gt;  [1,] . 1 . 1
#&gt;  [2,] 1 . 1 2
#&gt;  [3,] . 1 . 1
#&gt;  [4,] 1 2 1 .
</code></pre>

<p>This time we also pick up the 3-cycle on vertices 2, 3 and 4.
Vertices 2 and 4 therefore occur in two distinct instances
of the motif, and so their motif adjacency matrix entries are equal
to two.</p>

<h2>Weighted motif adjacency matrices</h2>

<p>Our example network \(\mathcal{G}_1\) has weighted edges,
which we have not yet used:
so far our MAMs have been simply counting
instances of motifs.
This is because the default weighting scheme is
&ldquo;unweighted&rdquo;, assigning every instance a weight of one.</p>

<h3>Mean-weighted instances</h3>

<p>We could instead use the &ldquo;mean&rdquo; weighting scheme,
where every instance is assigned a weight equal to its
mean edge weight.
The $(i,j)$th MAM entry is then defined as the sum of these
instance weights across all instances containing
both vertices \(i\) and \(j\):</p>

<pre><code class="r">build_motif_adjacency_matrix(G1, motif_name = &quot;M1&quot;, motif_type = &quot;func&quot;,
  mam_weight_type = &quot;mean&quot;)
#&gt;  4 x 4 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;              
#&gt;  [1,] . 3 . 3
#&gt;  [2,] 3 . 4 7
#&gt;  [3,] . 4 . 4
#&gt;  [4,] 3 7 4 .
</code></pre>

<p>The 3-cycle on vertices 1, 2 and 4
has edge weights of 2, 3 and 4, so its mean edge weight is 3.
Similarly the 3-cycle on vertices 2, 3 and 4 has mean edge weight of 4.
Vertices 2 and 4 appear in both, so their mutual MAM entries are the
sum of these two mean weights, which is 7.</p>

<h3>Product-weighted instances</h3>

<p>We can also use the &ldquo;product&rdquo; weighting scheme,
where every instance is assigned a weight equal to the
product of its edge weights.
The $(i,j)$th MAM entry is then defined as the sum of these
instance weights across all instances containing
both vertices \(i\) and \(j\):</p>

<pre><code class="r">build_motif_adjacency_matrix(G1, motif_name = &quot;M1&quot;, motif_type = &quot;func&quot;,
  mam_weight_type = &quot;product&quot;)
#&gt;  4 x 4 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;                  
#&gt;  [1,]  . 24  . 24
#&gt;  [2,] 24  . 60 84
#&gt;  [3,]  . 60  . 60
#&gt;  [4,] 24 84 60  .
</code></pre>

<p>The 3-cycle on vertices 1, 2 and 4
has edge weights of 2, 3 and 4, so the product of its edge weights is 24.
Similarly the 3-cycle on vertices 2, 3 and 4 has product of edge weights of 60.
Vertices 2 and 4 appear in both, so their shared MAM entries are the
sum of these two product weights, which is 84.</p>

<h3>Computation method</h3>

<p>The final argument to <code>build_motif_adjacency_matrix</code>
is the <code>mam_method</code> argument.
This does not affect the value returned but may impact the
amount of time taken to return the MAM.
In general the &ldquo;sparse&rdquo; method (the default)
is faster on large sparse networks.
The &ldquo;dense&rdquo; method, which uses fewer operations but on
denser matrices, tends to be faster for small dense networks.</p>

<pre><code class="r">mam_sparse &lt;- build_motif_adjacency_matrix(G1, motif_name = &quot;M1&quot;, mam_method = &quot;sparse&quot;)
mam_dense  &lt;- build_motif_adjacency_matrix(G1, motif_name = &quot;M1&quot;, mam_method = &quot;dense&quot;)
all(mam_sparse == mam_dense)
#&gt;  [1] TRUE
</code></pre>

<h1>Sampling random weighted directed networks</h1>

<p>Building adjacency matrices by hand is tedious,
so it is useful to have methods for generating
the adjacency matrices of networks drawn from some probabilistic model.
We use (weighted) directed stochastic block models (DSBMs) and
(weighted) bipartite stochastic block models (BSBMs).</p>

<h2>Directed stochastic block models</h2>

<p>First let&#39;s sample the adjacency matrix of a DSBM
which has two blocks of vertices;
the first containing five vertices and the second containing three.
We use strong within-block connections,
with the diagonal entries of the connection matrix set to \(0.9\).
The between-block connections are weaker, with the off-diagonal
connection matrix entries set to \(0.2\).
Note how the resulting adjacency matrix is denser
on its diagonal blocks
\(\{1, \dots, 5\} \times \{1, \dots, 5\}\)
and
\(\{6, \dots, 8\} \times \{6, \dots, 8\}\),
and is sparser on its off-diagonal blocks
\(\{1, \dots, 5\} \times \{6, \dots, 8\}\)
and
\(\{6, \dots, 8\} \times \{1, \dots, 5\}\).
The entries which lie exactly on the diagonal will
always be zero,
since we only consider networks without self-loops.</p>

<pre><code class="r">block_sizes = c(5, 3)
connection_matrix = matrix(c(
  0.9, 0.2,
  0.2, 0.9
), nrow = 2, byrow = TRUE)
</code></pre>

<p>\pagebreak</p>

<pre><code class="r">sample_dsbm(block_sizes, connection_matrix)
#&gt;  8 x 8 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;                      
#&gt;  [1,] . . 1 1 1 . . .
#&gt;  [2,] 1 . 1 . 1 . . .
#&gt;  [3,] 1 1 . 1 1 . . 1
#&gt;  [4,] 1 1 1 . 1 . 1 1
#&gt;  [5,] 1 1 1 1 . . . 1
#&gt;  [6,] . . . . . . . 1
#&gt;  [7,] . . 1 1 . 1 . 1
#&gt;  [8,] 1 . . . . 1 1 .
</code></pre>

<h3>Constant-weighted directed stochastic block models</h3>

<p>The matrix above has binary entries,
indicating that it is the adjacency matrix of an unweighted
directed network.
The <code>motifcluster</code> package also allows sampling of weighted directed networks.
The simplest example of this is &ldquo;constant&rdquo; weighting,
where we simply multiply each block of the adjacency matrix by a constant.</p>

<pre><code class="r">weight_matrix = matrix(c(
  5, 2,
  2, 5
), nrow = 2, byrow = TRUE)
sample_dsbm(block_sizes, connection_matrix, weight_matrix,
  sample_weight_type = &quot;constant&quot;)
#&gt;  8 x 8 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;                      
#&gt;  [1,] . 5 5 5 . . . .
#&gt;  [2,] 5 . 5 5 5 . 2 .
#&gt;  [3,] 5 5 . 5 5 . 2 .
#&gt;  [4,] 5 5 5 . 5 . . .
#&gt;  [5,] 5 5 5 5 . . . 2
#&gt;  [6,] . . 2 . . . 5 5
#&gt;  [7,] . . 2 . . 5 . 5
#&gt;  [8,] . . . . . 5 5 .
</code></pre>

<h3>Poisson-weighted directed stochastic block models</h3>

<p>We can also use weights drawn randomly from a Poisson distribution,
where each block in the adjacency matrix has its own mean parameter.
This returns an adjacency matrix with weights which could be any natural
number, but is equal in expectation to the constant version.
Note that in this scheme it is possible for the weight to be zero,
removing an edge which might have otherwise been present.</p>

<pre><code class="r">sample_dsbm(block_sizes, connection_matrix, weight_matrix, sample_weight_type = &quot;poisson&quot;)
#&gt;  8 x 8 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;                       
#&gt;  [1,] . 6 2 5 2 . 5  1
#&gt;  [2,] 3 . 4 6 . 2 .  .
#&gt;  [3,] 3 1 . 4 4 . .  .
#&gt;  [4,] 8 5 3 . 3 . .  .
#&gt;  [5,] . 1 5 5 . . .  .
#&gt;  [6,] . . . 2 . . 4  3
#&gt;  [7,] . . . . . 4 . 10
#&gt;  [8,] . . 2 . . 7 8  .
</code></pre>

<h2>Bipartite stochastic block models</h2>

<p>The <code>motifcluster</code> package can also be used to sample
bipartite networks.
The vertices of a bipartite network are partitioned
into &ldquo;source&rdquo; and &ldquo;destination&rdquo; vertices,
and edges are only permitted to go from source vertices
to destination vertices.
Let&#39;s sample a DSBM with a single block of two source vertices
and two blocks of destination vertices, with
sizes of three and two respectively.
We can use a strong connection probability of 0.9 to the first block of
destination vertices,
and a weaker connection probability of 0.2 to the second.</p>

<pre><code class="r">source_block_sizes = c(2)
destination_block_sizes = c(3, 2)
bipartite_connection_matrix = matrix(c(0.9, 0.2), nrow = 1)
sample_bsbm(source_block_sizes, destination_block_sizes, bipartite_connection_matrix)
#&gt;  7 x 7 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;                    
#&gt;  [1,] . . 1 1 1 . 1
#&gt;  [2,] . . 1 1 1 . .
#&gt;  [3,] . . . . . . .
#&gt;  [4,] . . . . . . .
#&gt;  [5,] . . . . . . .
#&gt;  [6,] . . . . . . .
#&gt;  [7,] . . . . . . .
</code></pre>

<h3>Weighted bipartite stochastic block models</h3>

<p>Similarly to the more general directed stochastic block models,
we can also use constant-weighted or Poisson-weighted edges for bipartite
stochastic block models.</p>

<pre><code class="r">bipartite_weight_matrix = matrix(c(7, 2), nrow = 1)
sample_bsbm(source_block_sizes, destination_block_sizes,
  bipartite_connection_matrix, bipartite_weight_matrix,
  sample_weight_type = &quot;poisson&quot;)
#&gt;  7 x 7 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;                     
#&gt;  [1,] . . 9 11 5 1 .
#&gt;  [2,] . . .  5 2 3 .
#&gt;  [3,] . . .  . . . .
#&gt;  [4,] . . .  . . . .
#&gt;  [5,] . . .  . . . .
#&gt;  [6,] . . .  . . . .
#&gt;  [7,] . . .  . . . .
</code></pre>

<h1>Spectral embedding with motif adjacency matrices</h1>

<p>Spectral methods involve performing eigenvalue and
eigenvector operations on matrices related to networks.
We work here with weighted <em>undirected</em> networks
(which have symmetric adjacency matrices),
because motif adjacency matrices are always symmetric.</p>

<h2>Laplacian matrices</h2>

<p>We can construct two types of Laplacian matrix for a network
using the <code>motifcluster</code> package.
First we create an example of a weighted undirected network \(\mathcal{G}_2\).</p>

<p>\pagebreak</p>

<pre><code class="r">G2 &lt;- matrix(c(
  0, 2, 0, 0,
  2, 0, 4, 3,
  0, 4, 0, 5,
  0, 3, 5, 0
), byrow = TRUE, nrow = 4)
</code></pre>

<h3>Combinatorial Laplacian</h3>

<p>The combinatorial Laplacian of an adjacency matrix \(G\) is
\(L_\mathrm{c} = D - G\),
where \(D\) is the diagonal matrix of weighted vertex degrees:</p>

<pre><code class="r">build_laplacian(G2, type_lap = &quot;comb&quot;)
#&gt;  4 x 4 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;                  
#&gt;  [1,]  2 -2  .  .
#&gt;  [2,] -2  9 -4 -3
#&gt;  [3,]  . -4  9 -5
#&gt;  [4,]  . -3 -5  8
</code></pre>

<h3>Random-walk Laplacian</h3>

<p>The random-walk Laplacian of an adjacency matrix \(G\) is
\(L_\mathrm{rw} = I - D^{-1}G\),
where \(D\) is the diagonal matrix of weighted vertex degrees
and \(I\) is the identity matrix:</p>

<pre><code class="r">build_laplacian(G2, type_lap = &quot;rw&quot;)
#&gt;  4 x 4 sparse Matrix of class &quot;dgCMatrix&quot;
#&gt;                              
#&gt;  [1,]  1.00 -1.00  .     .   
#&gt;  [2,] -0.22  1.00 -0.44 -0.33
#&gt;  [3,]  .    -0.44  1.00 -0.56
#&gt;  [4,]  .    -0.38 -0.62  1.00
</code></pre>

<h2>Laplace embedding</h2>

<p>Once we have constructed the desired Laplacian matrix,
we use it to embed each vertex into \(\mathbb{R}^l\)
by finding the eigenvectors associated with
its first (smallest magnitude) few eigenvalues.
Below we use the random-walk Laplacian,
and embedding dimension \(l=2\):</p>

<pre><code class="r">spectrum = run_laplace_embedding(G2, num_eigs = 2, type_lap = &quot;rw&quot;)
spectrum$vals
#&gt;  [1] -9.0e-17  7.9e-01
spectrum$vects
#&gt;       [,1]  [,2]
#&gt;  [1,]  0.5  0.93
#&gt;  [2,]  0.5  0.20
#&gt;  [3,]  0.5 -0.20
#&gt;  [4,]  0.5 -0.23
</code></pre>

<p>For a random-walk Laplacian,
the first eigenvalue is always zero (up to machine precision)
and its corresponding eigenvector is constant.</p>

<h2>Motif embedding</h2>

<p>Motif embedding is simply the process of building an MAM
and performing Laplace embedding with it.
As an example we use the
<code>run_motif_embedding</code>
function on the network \(\mathcal{G}_3\) below.</p>

<pre><code class="r">G3 &lt;- matrix(c(
  0, 0, 0, 0,
  0, 0, 2, 3,
  0, 4, 0, 0,
  4, 0, 5, 0
), byrow = TRUE, nrow = 4)
</code></pre>

<p>An artifact of building MAMs is that although the original network may
be connected, there is no guarantee that the MAM is also connected.
Hence the MAM is restricted to its largest connected component
before the Laplacian is formed.
We observe this with the network \(\mathcal{G}_3\),
in which only three of the four vertices are embedded.</p>

<pre><code class="r">spectrum = run_motif_embedding(G3, motif_name = &quot;M1&quot;, motif_type = &quot;func&quot;,
  mam_weight_type = &quot;unweighted&quot;, mam_method = &quot;sparse&quot;, num_eigs = 2,
  restrict = TRUE, type_lap = &quot;rw&quot;)
spectrum$vals
#&gt;  [1] 1.1e-15 1.5e+00
spectrum$vects
#&gt;       [,1]  [,2]
#&gt;  [1,] 0.58  0.00
#&gt;  [2,] 0.58 -0.71
#&gt;  [3,] 0.58  0.71
</code></pre>

<h1>Motif-based spectral clustering</h1>

<p>The overall aim of <code>motifcluster</code> is to use motifs for spectral clustering,
so now we see how to extract clusters from the motif-based
eigenvector embeddings.
The <code>run_motif_clustering</code> function handles the entire process of
building an MAM, restricting it to its largest connected component,
performing eigenvector embedding, and extracting clusters.
We therefore take the opportunity to showcase the ability of
<code>motifcluster</code> to recover the blocks of a DSBM,
demonstrating all of the methods outlined in this vignette.</p>

<p>Let&#39;s use a DSBM with three blocks of 10 nodes each.</p>

<pre><code class="r">block_sizes = rep(10, 3)
</code></pre>

<p>We use strong connections of 0.8 within the blocks,
and weaker connections of 0.3 between the blocks.</p>

<pre><code class="r">connection_matrix = matrix(c(
  0.8, 0.2, 0.2,
  0.2, 0.8, 0.2,
  0.2, 0.2, 0.8
), nrow = 3)
</code></pre>

<p>We also set the within-block edges to be Poisson-weighted with
mean 20,
and the between-block edges to be Poisson-weighted with smaller
mean 10.</p>

<pre><code class="r">weight_matrix = matrix(c(
  20, 10, 10,
  10, 20, 10,
  10, 10, 20
), nrow = 3)

G4 = sample_dsbm(block_sizes, connection_matrix, weight_matrix,
  sample_weight_type = &quot;poisson&quot;)
</code></pre>

<p>Now we can run the motif-based spectral clustering algorithm
on this network with the 3-cycle motif \(\mathcal{M}_1\).
We build a functional MAM,
weighting the instances by their mean edge weights,
using the sparse formulation.
We restrict this MAM to its largest connected component.
Then we construct a random-walk Laplacian and embed it using the
first four eigenvalues and eigenvectors.
Finally we extract three clusters.</p>

<pre><code class="r">motif_cluster = run_motif_clustering(G4, motif_name = &quot;M1&quot;, motif_type = &quot;func&quot;,
  mam_weight_type = &quot;mean&quot;, mam_method = &quot;sparse&quot;, type_lap = &quot;rw&quot;, num_eigs = 4,
  num_clusts = 3
)
</code></pre>

<p>We can evaluate the performance by comparing it to the ground-truth
labels using the adjusted Rand index
from the <code>mclust</code> package:</p>

<pre><code class="r">truth = c(rep(1, 10), rep(2, 10), rep(3, 10))
mclust::adjustedRandIndex(motif_cluster$clusts, truth)
#&gt;  [1] 1
</code></pre>

<p>A larger value indicates better recovery of the blocks,
with a value of one indicating perfect agreement.</p>

<h1>References</h1>

</body>

</html>
